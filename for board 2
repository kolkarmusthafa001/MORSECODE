module seven_seg_disp (
input [7:0] ascii_char,		// ASCII character input input clock,	// Clock signal
input wire letter_done,	// Signal that a letter is done to shift to the next display
input wire reset,	// Reset signal
output reg [6:0] seg_out,	// Seven-segment output for the active display output reg [3:0] current_display_out, // 8-bit register to track which displays are
active
output reg [3:0] current_display	// 8-bit register used to turn on/off displays
);


reg [6:0] seg; // Temporary register to hold the segment pattern reg [6:0] seg_sav [7:0]; // store segment patter for each display reg [1:0] counter;
reg [31:0] counter_big;
 


// 7-segment encoding for characters always @(*) begin
case (ascii_char)
// Numbers
8'b0000_0000: seg = 7'b1000000; // 0
8'b0000_0001 : seg = 7'b1111001; // 1
8'b0000_0010 : seg = 7'b0100100; // 2
8'b0000_0011 : seg = 7'b0110000; // 3
8'b0000_0100 : seg = 7'b0011001; // 4
8'b0000_0101 : seg = 7'b0010010; // 5
8'b0000_0110 : seg = 7'b0000010; // 6
8'b0000_0111 : seg = 7'b1111000; // 7
8'b0000_1000 : seg = 7'b0000000; // 8
8'b0000_1001 : seg = 7'b0010000; // 9
// Letters
8'b0000_1010 : seg = 7'b0001000; // a
8'b0000_1011 : seg = 7'b0000011; // b
8'b0000_1100 : seg = 7'b0100111; // c
8'b0000_1101 : seg = 7'b0100001; // d
8'b0000_1110 : seg = 7'b0000110; // e
8'b0000_1111 : seg = 7'b0001110; // f
8'b0001_0000 : seg = 7'b1000010; // g
8'b0001_0001 : seg = 7'b0001011; // h
8'b0001_0010 : seg = 7'b1111011; // i
8'b0001_0011 : seg = 7'b1110001; // j
8'b0001_0100 : seg = 7'b0001010; // k
 

8'b0001_0101 : seg = 7'b1000111; // l
8'b0001_0110 : seg = 7'b1001000; // m
8'b0001_0111 : seg = 7'b0101011; // n
8'b0001_1000 : seg = 7'b0100011; // o
8'b0001_1001 : seg = 7'b0001100; // p
8'b0001_1010 : seg = 7'b0011000; // q
8'b0001_1011 : seg = 7'b0101111; // r
8'b0001_1100 : seg = 7'b0011010; // s
8'b0001_1101 : seg = 7'b0000111; // t
8'b0001_1110 : seg = 7'b1100011; // u
8'b0001_1111 : seg = 7'b1110011; // v
8'b0010_0000 : seg = 7'b1000001; // w
8'b0010_0001 : seg = 7'b0001001; // x
8'b0010_0010 : seg = 7'b0010001; // y
8'b0010_0011 : seg = 7'b0101100; // z
8'b00101101: seg = 7'b1111110
;
// Default to blank default: seg = 7'b1111110;
endcase end
// Shift current_display on letter_done signal
always @(posedge letter_done or posedge reset) begin if (reset) begin
current_display <= 8'b11111111; // Reset to first display active (leftmost) end else begin
// Shift current_display to the right (move to the next display)
 

current_display <= {current_display[2:0], 1'b0}; end
end
always @(posedge clock or posedge reset) begin if (reset) begin
counter <= 0; // Reset to first display active (leftmost) counter_big <= 0;
end else begin
counter_big <= counter_big +1; if (counter_big==10000) begin counter <= counter+1;
counter_big <=0;
end case(counter) 4'd0:begin
current_display_out <= 4'b1110; seg_out <= seg_sav[0];
end 4'd1:begin
current_display_out <= 4'b0010; seg_out <= seg_sav[1];
end 4'd2:begin
current_display_out <= 4'b0100; seg_out <= seg_sav[2];
end 4'd3:begin
 

current_display_out <= 4'b1000; seg_out <= seg_sav[3];
end endcase
end end
// Display the corresponding segment on the active display always @(posedge clock or posedge reset) begin
if (reset) begin
seg_sav[0] <= 7'b1111111; seg_sav[1] <= 7'b1111111; seg_sav[2] <= 7'b1111111; seg_sav[3] <= 7'b1111111;

end else begin


case (current_display)
4'b1110: seg_sav[0] <= seg; // First display active 4'b1100: seg_sav[1] <= seg; // Second display active 4'b1000: seg_sav[2] <= seg; // Third display active 4'b0000: seg_sav[3] <= seg; // Fourth display active default: seg_sav[3] <= 7'b1111111; // Default to blank
endcase


end end
endmodule
